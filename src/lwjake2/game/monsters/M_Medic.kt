/*
 * Copyright (C) 1997-2001 Id Software, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package lwjake2.game.monsters

import lwjake2.Defines
import lwjake2.game.EdictIterator
import lwjake2.game.EntDieAdapter
import lwjake2.game.EntDodgeAdapter
import lwjake2.game.EntInteractAdapter
import lwjake2.game.EntPainAdapter
import lwjake2.game.EntThinkAdapter
import lwjake2.game.GameAI
import lwjake2.game.GameBase
import lwjake2.game.GameMisc
import lwjake2.game.GameSpawn
import lwjake2.game.GameUtil
import lwjake2.game.Monster
import lwjake2.game.edict_t
import lwjake2.game.mframe_t
import lwjake2.game.mmove_t
import lwjake2.game.trace_t
import lwjake2.game.monsters.M_Flash
import lwjake2.util.Lib
import lwjake2.util.Math3D

public class M_Medic {
    companion object {
        //	This file generated by ModelGen - Do NOT Modify

        public val FRAME_walk1: Int = 0

        public val FRAME_walk2: Int = 1

        public val FRAME_walk3: Int = 2

        public val FRAME_walk4: Int = 3

        public val FRAME_walk5: Int = 4

        public val FRAME_walk6: Int = 5

        public val FRAME_walk7: Int = 6

        public val FRAME_walk8: Int = 7

        public val FRAME_walk9: Int = 8

        public val FRAME_walk10: Int = 9

        public val FRAME_walk11: Int = 10

        public val FRAME_walk12: Int = 11

        public val FRAME_wait1: Int = 12

        public val FRAME_wait2: Int = 13

        public val FRAME_wait3: Int = 14

        public val FRAME_wait4: Int = 15

        public val FRAME_wait5: Int = 16

        public val FRAME_wait6: Int = 17

        public val FRAME_wait7: Int = 18

        public val FRAME_wait8: Int = 19

        public val FRAME_wait9: Int = 20

        public val FRAME_wait10: Int = 21

        public val FRAME_wait11: Int = 22

        public val FRAME_wait12: Int = 23

        public val FRAME_wait13: Int = 24

        public val FRAME_wait14: Int = 25

        public val FRAME_wait15: Int = 26

        public val FRAME_wait16: Int = 27

        public val FRAME_wait17: Int = 28

        public val FRAME_wait18: Int = 29

        public val FRAME_wait19: Int = 30

        public val FRAME_wait20: Int = 31

        public val FRAME_wait21: Int = 32

        public val FRAME_wait22: Int = 33

        public val FRAME_wait23: Int = 34

        public val FRAME_wait24: Int = 35

        public val FRAME_wait25: Int = 36

        public val FRAME_wait26: Int = 37

        public val FRAME_wait27: Int = 38

        public val FRAME_wait28: Int = 39

        public val FRAME_wait29: Int = 40

        public val FRAME_wait30: Int = 41

        public val FRAME_wait31: Int = 42

        public val FRAME_wait32: Int = 43

        public val FRAME_wait33: Int = 44

        public val FRAME_wait34: Int = 45

        public val FRAME_wait35: Int = 46

        public val FRAME_wait36: Int = 47

        public val FRAME_wait37: Int = 48

        public val FRAME_wait38: Int = 49

        public val FRAME_wait39: Int = 50

        public val FRAME_wait40: Int = 51

        public val FRAME_wait41: Int = 52

        public val FRAME_wait42: Int = 53

        public val FRAME_wait43: Int = 54

        public val FRAME_wait44: Int = 55

        public val FRAME_wait45: Int = 56

        public val FRAME_wait46: Int = 57

        public val FRAME_wait47: Int = 58

        public val FRAME_wait48: Int = 59

        public val FRAME_wait49: Int = 60

        public val FRAME_wait50: Int = 61

        public val FRAME_wait51: Int = 62

        public val FRAME_wait52: Int = 63

        public val FRAME_wait53: Int = 64

        public val FRAME_wait54: Int = 65

        public val FRAME_wait55: Int = 66

        public val FRAME_wait56: Int = 67

        public val FRAME_wait57: Int = 68

        public val FRAME_wait58: Int = 69

        public val FRAME_wait59: Int = 70

        public val FRAME_wait60: Int = 71

        public val FRAME_wait61: Int = 72

        public val FRAME_wait62: Int = 73

        public val FRAME_wait63: Int = 74

        public val FRAME_wait64: Int = 75

        public val FRAME_wait65: Int = 76

        public val FRAME_wait66: Int = 77

        public val FRAME_wait67: Int = 78

        public val FRAME_wait68: Int = 79

        public val FRAME_wait69: Int = 80

        public val FRAME_wait70: Int = 81

        public val FRAME_wait71: Int = 82

        public val FRAME_wait72: Int = 83

        public val FRAME_wait73: Int = 84

        public val FRAME_wait74: Int = 85

        public val FRAME_wait75: Int = 86

        public val FRAME_wait76: Int = 87

        public val FRAME_wait77: Int = 88

        public val FRAME_wait78: Int = 89

        public val FRAME_wait79: Int = 90

        public val FRAME_wait80: Int = 91

        public val FRAME_wait81: Int = 92

        public val FRAME_wait82: Int = 93

        public val FRAME_wait83: Int = 94

        public val FRAME_wait84: Int = 95

        public val FRAME_wait85: Int = 96

        public val FRAME_wait86: Int = 97

        public val FRAME_wait87: Int = 98

        public val FRAME_wait88: Int = 99

        public val FRAME_wait89: Int = 100

        public val FRAME_wait90: Int = 101

        public val FRAME_run1: Int = 102

        public val FRAME_run2: Int = 103

        public val FRAME_run3: Int = 104

        public val FRAME_run4: Int = 105

        public val FRAME_run5: Int = 106

        public val FRAME_run6: Int = 107

        public val FRAME_paina1: Int = 108

        public val FRAME_paina2: Int = 109

        public val FRAME_paina3: Int = 110

        public val FRAME_paina4: Int = 111

        public val FRAME_paina5: Int = 112

        public val FRAME_paina6: Int = 113

        public val FRAME_paina7: Int = 114

        public val FRAME_paina8: Int = 115

        public val FRAME_painb1: Int = 116

        public val FRAME_painb2: Int = 117

        public val FRAME_painb3: Int = 118

        public val FRAME_painb4: Int = 119

        public val FRAME_painb5: Int = 120

        public val FRAME_painb6: Int = 121

        public val FRAME_painb7: Int = 122

        public val FRAME_painb8: Int = 123

        public val FRAME_painb9: Int = 124

        public val FRAME_painb10: Int = 125

        public val FRAME_painb11: Int = 126

        public val FRAME_painb12: Int = 127

        public val FRAME_painb13: Int = 128

        public val FRAME_painb14: Int = 129

        public val FRAME_painb15: Int = 130

        public val FRAME_duck1: Int = 131

        public val FRAME_duck2: Int = 132

        public val FRAME_duck3: Int = 133

        public val FRAME_duck4: Int = 134

        public val FRAME_duck5: Int = 135

        public val FRAME_duck6: Int = 136

        public val FRAME_duck7: Int = 137

        public val FRAME_duck8: Int = 138

        public val FRAME_duck9: Int = 139

        public val FRAME_duck10: Int = 140

        public val FRAME_duck11: Int = 141

        public val FRAME_duck12: Int = 142

        public val FRAME_duck13: Int = 143

        public val FRAME_duck14: Int = 144

        public val FRAME_duck15: Int = 145

        public val FRAME_duck16: Int = 146

        public val FRAME_death1: Int = 147

        public val FRAME_death2: Int = 148

        public val FRAME_death3: Int = 149

        public val FRAME_death4: Int = 150

        public val FRAME_death5: Int = 151

        public val FRAME_death6: Int = 152

        public val FRAME_death7: Int = 153

        public val FRAME_death8: Int = 154

        public val FRAME_death9: Int = 155

        public val FRAME_death10: Int = 156

        public val FRAME_death11: Int = 157

        public val FRAME_death12: Int = 158

        public val FRAME_death13: Int = 159

        public val FRAME_death14: Int = 160

        public val FRAME_death15: Int = 161

        public val FRAME_death16: Int = 162

        public val FRAME_death17: Int = 163

        public val FRAME_death18: Int = 164

        public val FRAME_death19: Int = 165

        public val FRAME_death20: Int = 166

        public val FRAME_death21: Int = 167

        public val FRAME_death22: Int = 168

        public val FRAME_death23: Int = 169

        public val FRAME_death24: Int = 170

        public val FRAME_death25: Int = 171

        public val FRAME_death26: Int = 172

        public val FRAME_death27: Int = 173

        public val FRAME_death28: Int = 174

        public val FRAME_death29: Int = 175

        public val FRAME_death30: Int = 176

        public val FRAME_attack1: Int = 177

        public val FRAME_attack2: Int = 178

        public val FRAME_attack3: Int = 179

        public val FRAME_attack4: Int = 180

        public val FRAME_attack5: Int = 181

        public val FRAME_attack6: Int = 182

        public val FRAME_attack7: Int = 183

        public val FRAME_attack8: Int = 184

        public val FRAME_attack9: Int = 185

        public val FRAME_attack10: Int = 186

        public val FRAME_attack11: Int = 187

        public val FRAME_attack12: Int = 188

        public val FRAME_attack13: Int = 189

        public val FRAME_attack14: Int = 190

        public val FRAME_attack15: Int = 191

        public val FRAME_attack16: Int = 192

        public val FRAME_attack17: Int = 193

        public val FRAME_attack18: Int = 194

        public val FRAME_attack19: Int = 195

        public val FRAME_attack20: Int = 196

        public val FRAME_attack21: Int = 197

        public val FRAME_attack22: Int = 198

        public val FRAME_attack23: Int = 199

        public val FRAME_attack24: Int = 200

        public val FRAME_attack25: Int = 201

        public val FRAME_attack26: Int = 202

        public val FRAME_attack27: Int = 203

        public val FRAME_attack28: Int = 204

        public val FRAME_attack29: Int = 205

        public val FRAME_attack30: Int = 206

        public val FRAME_attack31: Int = 207

        public val FRAME_attack32: Int = 208

        public val FRAME_attack33: Int = 209

        public val FRAME_attack34: Int = 210

        public val FRAME_attack35: Int = 211

        public val FRAME_attack36: Int = 212

        public val FRAME_attack37: Int = 213

        public val FRAME_attack38: Int = 214

        public val FRAME_attack39: Int = 215

        public val FRAME_attack40: Int = 216

        public val FRAME_attack41: Int = 217

        public val FRAME_attack42: Int = 218

        public val FRAME_attack43: Int = 219

        public val FRAME_attack44: Int = 220

        public val FRAME_attack45: Int = 221

        public val FRAME_attack46: Int = 222

        public val FRAME_attack47: Int = 223

        public val FRAME_attack48: Int = 224

        public val FRAME_attack49: Int = 225

        public val FRAME_attack50: Int = 226

        public val FRAME_attack51: Int = 227

        public val FRAME_attack52: Int = 228

        public val FRAME_attack53: Int = 229

        public val FRAME_attack54: Int = 230

        public val FRAME_attack55: Int = 231

        public val FRAME_attack56: Int = 232

        public val FRAME_attack57: Int = 233

        public val FRAME_attack58: Int = 234

        public val FRAME_attack59: Int = 235

        public val FRAME_attack60: Int = 236

        public val MODEL_SCALE: Float = 1.000000.toFloat()

        var sound_idle1: Int = 0

        var sound_pain1: Int = 0

        var sound_pain2: Int = 0

        var sound_die: Int = 0

        var sound_sight: Int = 0

        var sound_search: Int = 0

        var sound_hook_launch: Int = 0

        var sound_hook_hit: Int = 0

        var sound_hook_heal: Int = 0

        var sound_hook_retract: Int = 0

        fun medic_FindDeadMonster(self: edict_t): edict_t {
            var ent: edict_t? = null
            var best: edict_t? = null
            var edit: EdictIterator? = null

            while ((edit = GameBase.findradius(edit, self.s.origin, 1024)) != null) {
                ent = edit!!.o
                if (ent == self)
                    continue
                if (0 == (ent!!.svflags and Defines.SVF_MONSTER))
                    continue
                if ((ent!!.monsterinfo.aiflags and Defines.AI_GOOD_GUY) != 0)
                    continue
                if (ent!!.owner == null)
                    continue
                if (ent!!.health > 0)
                    continue
                if (ent!!.nextthink == 0)
                    continue
                if (!GameUtil.visible(self, ent))
                    continue
                if (best == null) {
                    best = ent
                    continue
                }
                if (ent!!.max_health <= best!!.max_health)
                    continue
                best = ent
            }

            return best
        }

        var medic_idle: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_idle"
            }

            public fun think(self: edict_t): Boolean {
                val ent: edict_t?

                GameBase.gi.sound(self, Defines.CHAN_VOICE, sound_idle1, 1, Defines.ATTN_IDLE, 0)

                ent = medic_FindDeadMonster(self)
                if (ent != null) {
                    self.enemy = ent
                    self.enemy.owner = self
                    self.monsterinfo.aiflags = self.monsterinfo.aiflags or Defines.AI_MEDIC
                    GameUtil.FoundTarget(self)
                }
                return true
            }
        }

        var medic_search: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_search"
            }

            public fun think(self: edict_t): Boolean {
                val ent: edict_t?

                GameBase.gi.sound(self, Defines.CHAN_VOICE, sound_search, 1, Defines.ATTN_IDLE, 0)

                if (self.oldenemy == null) {
                    ent = medic_FindDeadMonster(self)
                    if (ent != null) {
                        self.oldenemy = self.enemy
                        self.enemy = ent
                        self.enemy.owner = self
                        self.monsterinfo.aiflags = self.monsterinfo.aiflags or Defines.AI_MEDIC
                        GameUtil.FoundTarget(self)
                    }
                }
                return true
            }
        }

        var medic_sight: EntInteractAdapter = object : EntInteractAdapter() {
            public fun getID(): String {
                return "medic_sight"
            }

            public fun interact(self: edict_t, other: edict_t): Boolean {
                GameBase.gi.sound(self, Defines.CHAN_VOICE, sound_sight, 1, Defines.ATTN_NORM, 0)
                return true
            }
        }

        var medic_frames_stand = array<mframe_t>(mframe_t(GameAI.ai_stand, 0, medic_idle), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null), mframe_t(GameAI.ai_stand, 0, null))

        var medic_move_stand = mmove_t(FRAME_wait1, FRAME_wait90, medic_frames_stand, null)

        var medic_stand: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_stand"
            }

            public fun think(self: edict_t): Boolean {
                self.monsterinfo.currentmove = medic_move_stand
                return true
            }
        }

        var medic_frames_walk = array<mframe_t>(mframe_t(GameAI.ai_walk, 6.2.toFloat(), null), mframe_t(GameAI.ai_walk, 18.1.toFloat(), null), mframe_t(GameAI.ai_walk, 1, null), mframe_t(GameAI.ai_walk, 9, null), mframe_t(GameAI.ai_walk, 10, null), mframe_t(GameAI.ai_walk, 9, null), mframe_t(GameAI.ai_walk, 11, null), mframe_t(GameAI.ai_walk, 11.6.toFloat(), null), mframe_t(GameAI.ai_walk, 2, null), mframe_t(GameAI.ai_walk, 9.9.toFloat(), null), mframe_t(GameAI.ai_walk, 14, null), mframe_t(GameAI.ai_walk, 9.3.toFloat(), null))

        var medic_move_walk = mmove_t(FRAME_walk1, FRAME_walk12, medic_frames_walk, null)

        var medic_walk: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_walk"
            }

            public fun think(self: edict_t): Boolean {
                self.monsterinfo.currentmove = medic_move_walk
                return true
            }
        }

        var medic_frames_run = array<mframe_t>(mframe_t(GameAI.ai_run, 18, null), mframe_t(GameAI.ai_run, 22.5.toFloat(), null), mframe_t(GameAI.ai_run, 25.4.toFloat(), null), mframe_t(GameAI.ai_run, 23.4.toFloat(), null), mframe_t(GameAI.ai_run, 24, null), mframe_t(GameAI.ai_run, 35.6.toFloat(), null))

        var medic_move_run = mmove_t(FRAME_run1, FRAME_run6, medic_frames_run, null)

        var medic_run: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_run"
            }

            public fun think(self: edict_t): Boolean {
                if (0 == (self.monsterinfo.aiflags and Defines.AI_MEDIC)) {
                    val ent: edict_t?

                    ent = medic_FindDeadMonster(self)
                    if (ent != null) {
                        self.oldenemy = self.enemy
                        self.enemy = ent
                        self.enemy.owner = self
                        self.monsterinfo.aiflags = self.monsterinfo.aiflags or Defines.AI_MEDIC
                        GameUtil.FoundTarget(self)
                        return true
                    }
                }

                if ((self.monsterinfo.aiflags and Defines.AI_STAND_GROUND) != 0)
                    self.monsterinfo.currentmove = medic_move_stand
                else
                    self.monsterinfo.currentmove = medic_move_run
                return true
            }
        }

        var medic_frames_pain1 = array<mframe_t>(mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null))

        var medic_move_pain1 = mmove_t(FRAME_paina1, FRAME_paina8, medic_frames_pain1, medic_run)

        var medic_frames_pain2 = array<mframe_t>(mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null))

        var medic_move_pain2 = mmove_t(FRAME_painb1, FRAME_painb15, medic_frames_pain2, medic_run)

        var medic_pain: EntPainAdapter = object : EntPainAdapter() {
            public fun getID(): String {
                return "medic_pain"
            }

            public fun pain(self: edict_t, other: edict_t, kick: Float, damage: Int) {

                if (self.health < (self.max_health / 2))
                    self.s.skinnum = 1

                if (GameBase.level.time < self.pain_debounce_time)
                    return

                self.pain_debounce_time = GameBase.level.time + 3

                if (GameBase.skill.value == 3)
                    return  // no pain anims in nightmare

                if (Lib.random() < 0.5) {
                    self.monsterinfo.currentmove = medic_move_pain1
                    GameBase.gi.sound(self, Defines.CHAN_VOICE, sound_pain1, 1, Defines.ATTN_NORM, 0)
                } else {
                    self.monsterinfo.currentmove = medic_move_pain2
                    GameBase.gi.sound(self, Defines.CHAN_VOICE, sound_pain2, 1, Defines.ATTN_NORM, 0)
                }
            }
        }

        var medic_fire_blaster: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_fire_blaster"
            }

            public fun think(self: edict_t): Boolean {
                val start = floatArray(0.0, 0.0, 0.0)
                val forward = floatArray(0.0, 0.0, 0.0)
                val right = floatArray(0.0, 0.0, 0.0)
                val end = floatArray(0.0, 0.0, 0.0)
                val dir = floatArray(0.0, 0.0, 0.0)
                val effect: Int

                if ((self.s.frame == FRAME_attack9) || (self.s.frame == FRAME_attack12))
                    effect = Defines.EF_BLASTER
                else if ((self.s.frame == FRAME_attack19) || (self.s.frame == FRAME_attack22) || (self.s.frame == FRAME_attack25) || (self.s.frame == FRAME_attack28))
                    effect = Defines.EF_HYPERBLASTER
                else
                    effect = 0

                Math3D.AngleVectors(self.s.angles, forward, right, null)
                Math3D.G_ProjectSource(self.s.origin, M_Flash.monster_flash_offset[Defines.MZ2_MEDIC_BLASTER_1], forward, right, start)

                Math3D.VectorCopy(self.enemy.s.origin, end)
                end[2] += self.enemy.viewheight
                Math3D.VectorSubtract(end, start, dir)

                Monster.monster_fire_blaster(self, start, dir, 2, 1000, Defines.MZ2_MEDIC_BLASTER_1, effect)
                return true
            }
        }

        var medic_dead: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_dead"
            }

            public fun think(self: edict_t): Boolean {
                Math3D.VectorSet(self.mins, -16, -16, -24)
                Math3D.VectorSet(self.maxs, 16, 16, -8)
                self.movetype = Defines.MOVETYPE_TOSS
                self.svflags = self.svflags or Defines.SVF_DEADMONSTER
                self.nextthink = 0
                GameBase.gi.linkentity(self)
                return true
            }
        }

        var medic_frames_death = array<mframe_t>(mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null), mframe_t(GameAI.ai_move, 0, null))

        var medic_move_death = mmove_t(FRAME_death1, FRAME_death30, medic_frames_death, medic_dead)

        var medic_die: EntDieAdapter = object : EntDieAdapter() {
            public fun getID(): String {
                return "medic_die"
            }

            public fun die(self: edict_t, inflictor: edict_t, attacker: edict_t, damage: Int, point: FloatArray) {

                var n: Int

                // if we had a pending patient, free him up for another medic
                if ((self.enemy != null) && (self.enemy.owner == self))
                    self.enemy.owner = null

                //	check for gib
                if (self.health <= self.gib_health) {
                    GameBase.gi.sound(self, Defines.CHAN_VOICE, GameBase.gi.soundindex("misc/udeath.wav"), 1, Defines.ATTN_NORM, 0)
                    run {
                        n = 0
                        while (n < 2) {
                            GameMisc.ThrowGib(self, "models/objects/gibs/bone/tris.md2", damage, Defines.GIB_ORGANIC)
                            n++
                        }
                    }
                    run {
                        n = 0
                        while (n < 4) {
                            GameMisc.ThrowGib(self, "models/objects/gibs/sm_meat/tris.md2", damage, Defines.GIB_ORGANIC)
                            n++
                        }
                    }
                    GameMisc.ThrowHead(self, "models/objects/gibs/head2/tris.md2", damage, Defines.GIB_ORGANIC)
                    self.deadflag = Defines.DEAD_DEAD
                    return
                }

                if (self.deadflag == Defines.DEAD_DEAD)
                    return

                //	regular death
                GameBase.gi.sound(self, Defines.CHAN_VOICE, sound_die, 1, Defines.ATTN_NORM, 0)
                self.deadflag = Defines.DEAD_DEAD
                self.takedamage = Defines.DAMAGE_YES

                self.monsterinfo.currentmove = medic_move_death
            }
        }

        var medic_duck_down: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_duck_down"
            }

            public fun think(self: edict_t): Boolean {
                if ((self.monsterinfo.aiflags and Defines.AI_DUCKED) != 0)
                    return true
                self.monsterinfo.aiflags = self.monsterinfo.aiflags or Defines.AI_DUCKED
                self.maxs[2] -= 32
                self.takedamage = Defines.DAMAGE_YES
                self.monsterinfo.pausetime = GameBase.level.time + 1
                GameBase.gi.linkentity(self)
                return true
            }
        }

        var medic_duck_hold: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_duck_hold"
            }

            public fun think(self: edict_t): Boolean {
                if (GameBase.level.time >= self.monsterinfo.pausetime)
                    self.monsterinfo.aiflags = self.monsterinfo.aiflags and Defines.AI_HOLD_FRAME.inv()
                else
                    self.monsterinfo.aiflags = self.monsterinfo.aiflags or Defines.AI_HOLD_FRAME
                return true
            }
        }

        var medic_duck_up: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_duck_up"
            }

            public fun think(self: edict_t): Boolean {
                self.monsterinfo.aiflags = self.monsterinfo.aiflags and Defines.AI_DUCKED.inv()
                self.maxs[2] += 32
                self.takedamage = Defines.DAMAGE_AIM
                GameBase.gi.linkentity(self)
                return true
            }
        }

        var medic_frames_duck = array<mframe_t>(mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, medic_duck_down), mframe_t(GameAI.ai_move, -1, medic_duck_hold), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, medic_duck_up), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null), mframe_t(GameAI.ai_move, -1, null))

        var medic_move_duck = mmove_t(FRAME_duck1, FRAME_duck16, medic_frames_duck, medic_run)

        var medic_dodge: EntDodgeAdapter = object : EntDodgeAdapter() {
            public fun getID(): String {
                return "medic_dodge"
            }

            public fun dodge(self: edict_t, attacker: edict_t, eta: Float) {
                if (Lib.random() > 0.25)
                    return

                if (self.enemy == null)
                    self.enemy = attacker

                self.monsterinfo.currentmove = medic_move_duck
            }
        }

        var medic_frames_attackHyperBlaster = array<mframe_t>(mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster))

        var medic_move_attackHyperBlaster = mmove_t(FRAME_attack15, FRAME_attack30, medic_frames_attackHyperBlaster, medic_run)

        var medic_continue: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_continue"
            }

            public fun think(self: edict_t): Boolean {
                if (GameUtil.visible(self, self.enemy))
                    if (Lib.random() <= 0.95)
                        self.monsterinfo.currentmove = medic_move_attackHyperBlaster
                return true
            }
        }

        var medic_frames_attackBlaster = array<mframe_t>(mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 5, null), mframe_t(GameAI.ai_charge, 5, null), mframe_t(GameAI.ai_charge, 3, null), mframe_t(GameAI.ai_charge, 2, null), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, medic_fire_blaster), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_charge, 0, medic_continue) // Change to
        )// medic_continue...
        // Else, go to
        // frame 32

        var medic_move_attackBlaster = mmove_t(FRAME_attack1, FRAME_attack14, medic_frames_attackBlaster, medic_run)

        var medic_hook_launch: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_hook_launch"
            }

            public fun think(self: edict_t): Boolean {
                GameBase.gi.sound(self, Defines.CHAN_WEAPON, sound_hook_launch, 1, Defines.ATTN_NORM, 0)
                return true
            }
        }

        var medic_cable_offsets = array<FloatArray>(floatArray(45.0.toFloat(), (-9.2.toFloat()).toFloat(), 15.5.toFloat()).toFloat(), floatArray(48.4.toFloat(), (-9.7.toFloat()).toFloat(), 15.2.toFloat()).toFloat(), floatArray(47.8.toFloat(), (-9.8.toFloat()).toFloat(), 15.8.toFloat()).toFloat(), floatArray(47.3.toFloat(), (-9.3.toFloat()).toFloat(), 14.3.toFloat()).toFloat(), floatArray(45.4.toFloat(), (-10.1.toFloat()).toFloat(), 13.1.toFloat()).toFloat(), floatArray(41.9.toFloat(), (-12.7.toFloat()).toFloat(), 12.0.toFloat()).toFloat(), floatArray(37.8.toFloat(), (-15.8.toFloat()).toFloat(), 11.2.toFloat()).toFloat(), floatArray(34.3.toFloat(), (-18.4.toFloat()).toFloat(), 10.7.toFloat()).toFloat(), floatArray(32.7.toFloat(), (-19.7.toFloat()).toFloat(), 10.4.toFloat()).toFloat(), floatArray(32.7.toFloat(), (-19.7.toFloat()).toFloat(), 10.4.toFloat()).toFloat())

        var medic_cable_attack: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_cable_attack"
            }

            public fun think(self: edict_t): Boolean {
                val offset = floatArray(0.0, 0.0, 0.0)
                val start = floatArray(0.0, 0.0, 0.0)
                val end = floatArray(0.0, 0.0, 0.0)
                val f = floatArray(0.0, 0.0, 0.0)
                val r = floatArray(0.0, 0.0, 0.0)
                val tr: trace_t
                val dir = floatArray(0.0, 0.0, 0.0)
                val angles = floatArray(0.0, 0.0, 0.0)
                val distance: Float

                if (!self.enemy.inuse)
                    return true

                Math3D.AngleVectors(self.s.angles, f, r, null)
                Math3D.VectorCopy(medic_cable_offsets[self.s.frame - FRAME_attack42], offset)
                Math3D.G_ProjectSource(self.s.origin, offset, f, r, start)

                // check for max distance
                Math3D.VectorSubtract(start, self.enemy.s.origin, dir)
                distance = Math3D.VectorLength(dir)
                if (distance > 256)
                    return true

                // check for min/max pitch
                Math3D.vectoangles(dir, angles)
                if (angles[0] < -180)
                    angles[0] += 360
                if (Math.abs(angles[0]) > 45)
                    return true

                tr = GameBase.gi.trace(start, null, null, self.enemy.s.origin, self, Defines.MASK_SHOT)
                if (tr.fraction != 1.0 && tr.ent != self.enemy)
                    return true

                if (self.s.frame == FRAME_attack43) {
                    GameBase.gi.sound(self.enemy, Defines.CHAN_AUTO, sound_hook_hit, 1, Defines.ATTN_NORM, 0)
                    self.enemy.monsterinfo.aiflags = self.enemy.monsterinfo.aiflags or Defines.AI_RESURRECTING
                } else if (self.s.frame == FRAME_attack50) {
                    self.enemy.spawnflags = 0
                    self.enemy.monsterinfo.aiflags = 0
                    self.enemy.target = null
                    self.enemy.targetname = null
                    self.enemy.combattarget = null
                    self.enemy.deathtarget = null
                    self.enemy.owner = self
                    GameSpawn.ED_CallSpawn(self.enemy)
                    self.enemy.owner = null
                    if (self.enemy.think != null) {
                        self.enemy.nextthink = GameBase.level.time
                        self.enemy.think.think(self.enemy)
                    }
                    self.enemy.monsterinfo.aiflags = self.enemy.monsterinfo.aiflags or Defines.AI_RESURRECTING
                    if (self.oldenemy != null && self.oldenemy.client != null) {
                        self.enemy.enemy = self.oldenemy
                        GameUtil.FoundTarget(self.enemy)
                    }
                } else {
                    if (self.s.frame == FRAME_attack44)
                        GameBase.gi.sound(self, Defines.CHAN_WEAPON, sound_hook_heal, 1, Defines.ATTN_NORM, 0)
                }

                // adjust start for beam origin being in middle of a segment
                Math3D.VectorMA(start, 8, f, start)

                // adjust end z for end spot since the monster is currently dead
                Math3D.VectorCopy(self.enemy.s.origin, end)
                end[2] = self.enemy.absmin[2] + self.enemy.size[2] / 2

                GameBase.gi.WriteByte(Defines.svc_temp_entity)
                GameBase.gi.WriteByte(Defines.TE_MEDIC_CABLE_ATTACK)
                GameBase.gi.WriteShort(self.index)
                GameBase.gi.WritePosition(start)
                GameBase.gi.WritePosition(end)
                GameBase.gi.multicast(self.s.origin, Defines.MULTICAST_PVS)
                return true
            }
        }

        var medic_hook_retract: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_hook_retract"
            }

            public fun think(self: edict_t): Boolean {
                GameBase.gi.sound(self, Defines.CHAN_WEAPON, sound_hook_retract, 1, Defines.ATTN_NORM, 0)
                self.enemy.monsterinfo.aiflags = self.enemy.monsterinfo.aiflags and Defines.AI_RESURRECTING.inv()
                return true
            }
        }

        var medic_frames_attackCable = array<mframe_t>(mframe_t(GameAI.ai_move, 2, null), mframe_t(GameAI.ai_move, 3, null), mframe_t(GameAI.ai_move, 5, null), mframe_t(GameAI.ai_move, 4.4.toFloat(), null), mframe_t(GameAI.ai_charge, 4.7.toFloat(), null), mframe_t(GameAI.ai_charge, 5, null), mframe_t(GameAI.ai_charge, 6, null), mframe_t(GameAI.ai_charge, 4, null), mframe_t(GameAI.ai_charge, 0, null), mframe_t(GameAI.ai_move, 0, medic_hook_launch), mframe_t(GameAI.ai_move, 0, medic_cable_attack), mframe_t(GameAI.ai_move, 0, medic_cable_attack), mframe_t(GameAI.ai_move, 0, medic_cable_attack), mframe_t(GameAI.ai_move, 0, medic_cable_attack), mframe_t(GameAI.ai_move, 0, medic_cable_attack), mframe_t(GameAI.ai_move, 0, medic_cable_attack), mframe_t(GameAI.ai_move, 0, medic_cable_attack), mframe_t(GameAI.ai_move, 0, medic_cable_attack), mframe_t(GameAI.ai_move, 0, medic_cable_attack), mframe_t(GameAI.ai_move, -15, medic_hook_retract), mframe_t(GameAI.ai_move, -1.5.toFloat(), null), mframe_t(GameAI.ai_move, -1.2.toFloat(), null), mframe_t(GameAI.ai_move, -3, null), mframe_t(GameAI.ai_move, -2, null), mframe_t(GameAI.ai_move, 0.3.toFloat(), null), mframe_t(GameAI.ai_move, 0.7.toFloat(), null), mframe_t(GameAI.ai_move, 1.2.toFloat(), null), mframe_t(GameAI.ai_move, 1.3.toFloat(), null))

        var medic_move_attackCable = mmove_t(FRAME_attack33, FRAME_attack60, medic_frames_attackCable, medic_run)

        var medic_attack: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_attack"
            }

            public fun think(self: edict_t): Boolean {
                if ((self.monsterinfo.aiflags and Defines.AI_MEDIC) != 0)
                    self.monsterinfo.currentmove = medic_move_attackCable
                else
                    self.monsterinfo.currentmove = medic_move_attackBlaster
                return true
            }
        }

        var medic_checkattack: EntThinkAdapter = object : EntThinkAdapter() {
            public fun getID(): String {
                return "medic_checkattack"
            }

            public fun think(self: edict_t): Boolean {
                if ((self.monsterinfo.aiflags and Defines.AI_MEDIC) != 0) {
                    medic_attack.think(self)
                    return true
                }

                return GameUtil.M_CheckAttack.think(self)

            }
        }

        /*
     * QUAKED monster_medic (1 .5 0) (-16 -16 -24) (16 16 32) Ambush
     * Trigger_Spawn Sight
     */
        public fun SP_monster_medic(self: edict_t) {
            if (GameBase.deathmatch.value != 0) {
                GameUtil.G_FreeEdict(self)
                return
            }

            sound_idle1 = GameBase.gi.soundindex("medic/idle.wav")
            sound_pain1 = GameBase.gi.soundindex("medic/medpain1.wav")
            sound_pain2 = GameBase.gi.soundindex("medic/medpain2.wav")
            sound_die = GameBase.gi.soundindex("medic/meddeth1.wav")
            sound_sight = GameBase.gi.soundindex("medic/medsght1.wav")
            sound_search = GameBase.gi.soundindex("medic/medsrch1.wav")
            sound_hook_launch = GameBase.gi.soundindex("medic/medatck2.wav")
            sound_hook_hit = GameBase.gi.soundindex("medic/medatck3.wav")
            sound_hook_heal = GameBase.gi.soundindex("medic/medatck4.wav")
            sound_hook_retract = GameBase.gi.soundindex("medic/medatck5.wav")

            GameBase.gi.soundindex("medic/medatck1.wav")

            self.movetype = Defines.MOVETYPE_STEP
            self.solid = Defines.SOLID_BBOX
            self.s.modelindex = GameBase.gi.modelindex("models/monsters/medic/tris.md2")
            Math3D.VectorSet(self.mins, -24, -24, -24)
            Math3D.VectorSet(self.maxs, 24, 24, 32)

            self.health = 300
            self.gib_health = -130
            self.mass = 400

            self.pain = medic_pain
            self.die = medic_die

            self.monsterinfo.stand = medic_stand
            self.monsterinfo.walk = medic_walk
            self.monsterinfo.run = medic_run
            self.monsterinfo.dodge = medic_dodge
            self.monsterinfo.attack = medic_attack
            self.monsterinfo.melee = null
            self.monsterinfo.sight = medic_sight
            self.monsterinfo.idle = medic_idle
            self.monsterinfo.search = medic_search
            self.monsterinfo.checkattack = medic_checkattack

            GameBase.gi.linkentity(self)

            self.monsterinfo.currentmove = medic_move_stand
            self.monsterinfo.scale = MODEL_SCALE

            GameAI.walkmonster_start.think(self)
        }
    }
}